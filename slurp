#!/bin/bash
# ingest several repos

set -x
set -eu

# $1: URL to clone
import() {
    URL="$1"

    DIR="${URL##*/}"
    CDIR=clones/"$DIR"
    mkdir -p clones
    if ! test -d "$CDIR"; then
        git clone "$URL" "$CDIR"
        pushd "$CDIR"
        git-filter-repo --to-subdirectory-filter "$DIR"
        popd
    fi

    git remote add "$R" "$CDIR"
    git fetch "$R"
}

LIBYUI_REPOS=(
    libyui
    libyui-bindings
    libyui-rest-api
    libyui-ncurses          libyui-qt
                            libyui-qt-graph
    libyui-ncurses-pkg      libyui-qt-pkg
    libyui-ncurses-rest-api libyui-qt-rest-api
)

# short version for prototyping
# LIBYUI_REPOS=(libyui libyui-ncurses libyui-qt)

MSG="Empty initial commit"
if ! test -d .git; then
    git init .
    git commit --allow-empty -m "$MSG"
fi
FIRST_COMMIT=$(git rev-list --max-count=1 --fixed-strings --grep="$MSG" HEAD)

merge_master() {
    for R in "${LIBYUI_REPOS[@]}"; do
        import https://github.com/libyui/"$R"

        git reset --hard "$FIRST_COMMIT"
        git commit --allow-empty -m "Empty parent commit for $R"
        EMPTY_PARENT=$(git rev-list --max-count=1 HEAD)

        BRANCH_INITIAL_COMMIT=$(git rev-list --max-parents=0 "$R"/master)
        git replace --graft "$BRANCH_INITIAL_COMMIT" "$EMPTY_PARENT"
    done
    git merge -m "Mooooooooerge!!" "${LIBYUI_REPOS[@]/%/\/master}"
}

merge_master

# sed does
#   libyui/foo
#   libyui-qt/bar/baz
# ->
#   foo
#   bar/baz
BRANCHES=$(git branch --remotes | sed 's@[^/]*/@@' | sort --uniq)

branch_exists() {
    git rev-list --quiet "$1" -- 2>/dev/null
}

needs_common_origin() {
    case "$1" in
        # "fatal: refusing to merge unrelated histories"
        openSUSE-10_0|openSUSE-10_1|openSUSE-10_2|openSUSE-10_3)
            return 0;;
        openSUSE-9_3|SLE-10|SLE-10-SP1|SLE-10-SP2|SLE-10-SP3|SLE-10-SP4|SLE-10-SP4-Code11-Backport)
            return 0;;
        *)
            return 1;;
    esac
}

for B in $BRANCHES; do
    if branch_exists "$B"; then continue; fi
    # TODO: do something similar to master: create an artificial common commit
    if needs_common_origin "$B"; then continue; fi

    ONE_REMOTE=$(git branch --remotes | sed -n "s@ *\([^/]*\)/$B\$@\1@;T;p;q")
    git switch --no-track --create "$B" "${ONE_REMOTE}"/"$B"
    git merge --ff -m "Mooerge $B" $(git branch --remotes | grep "/$B$")
done
